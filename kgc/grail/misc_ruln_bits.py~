import numpy as np
from tqdm import tqdm
import csv
import random
import copy

def load_data(fp):
    data = {}
    data_s = {}

    with open(fp, "r") as fd:
        rd = csv.reader(fd, delimiter="\t")
        for row in rd:
            (s, r, o)  = row
            
            if r not in data:
                data[r] = {}
            if s not in data[r]:
                data[r][s] = [o]
            else:
                data[r][s].append(o)

            if s not in data_s:
                data_s[s] = {}
            if r not in data_s[s]:
                data_s[s][r] = [o]
            else:
                data_s[s][r].append(o) 
    
    return data, data_s

#randomly select target tuple
def select_target(data):

    r, s_dict = random.choice(list(data.items()))
    s, o_list = random.choice(list(s_dict.items()))
    o = random.choice(o_list)
    
    
    return (s,r,o)

#given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
def find_surrounding_nodes(data_s, s, target_o, steps, k, paths, prev_path):
    if s not in data_s:
        return
    out = []
    for r, o_list in data_s[s].items():
        for o in o_list:
            #print("PREV PATH: {}".format(len(prev_path)))
            cur_path = prev_path + (r,)
            #print("CUR PATH: {}".format(len(cur_path)))
            #print("CUR PATH: {}".format(cur_path))
            if o == target_o:
                path = tuple(cur_path)
                #print("PATH: {}".format(path))
                if path not in paths:
                    paths[path] = 1
                else:
                    paths[path] += 1
                continue
            if steps < k-1:
                find_surrounding_nodes(data_s, o, target_o, steps + 1, k, paths, cur_path)
                

#given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
def find_surrounding_nodes_triples(data_s, s, target_o, steps, k, paths, prev_path):
    if s not in data_s:
        return
    
    for r, o_list in data_s[s].items():
        for o in o_list:
            #print("PREV PATH: {}".format(len(prev_path)))
            cur_path = prev_path + (s,)
            #print("CUR PATH: {}".format(len(cur_path)))
            #print("CUR PATH: {}".format(cur_path))
            if o == target_o:
                path = tuple(cur_path)
                #print("PATH: {}".format(path))
                if path not in paths:
                    paths[path] = 1
                else:
                    paths[path] += 1
                continue
            if steps < k-1:
                find_surrounding_nodes_triples(data_s, o, target_o, steps + 1, k, paths, cur_path)
                
                    
    

#given r, random sample relations to find path prominence
def random_sample_relation(data, data_s, relation, sample_no=10, k = 2):
    rel_dict = data[relation]
    s_list = list(rel_dict.keys())
    
    #TODO: SO_LIST for multiple o's with same sr
    if len(s_list) == 0:
        return {}
    chosen_s = random.sample(s_list, min(sample_no, len(s_list)))

    paths = {}
    
    

    for s in chosen_s:
        cur_path = ()
        steps = 0
        target_o = rel_dict[s][0]
        
        find_surrounding_nodes(data_s, s, target_o, steps, k, paths, cur_path)
        #visited = set()
        #visited.add(s)
        #target_o = rel_dict[s][0]
        #depth = 0

        
        #for r in data_s[s].keys():
            
            
            
        
    

        
    #print(len(paths))
    pks = paths.keys()
    for k in pks:
        paths[k] = min(paths[k]/len(chosen_s), 1.0)
    return paths

def path_check(s, path, hop, data_s):
    found = []
    if len(path) == hop:
        return [s]
    r = path[hop]
    if s in data_s and r in data_s[s]:
        for o in data_s[s][r]:
            found += path_check(o, path, hop + 1, data_s)
    return found

#given s and r, what is best o?
def rulen(s, r, o, paths, data, data_s, rules, max_sub=0):
    all_found = []
    for path in paths:
       found = path_check(s, path, 0, data_s)
       if found:
           all_found.append((found, path, paths[path]))
           
    all_found.sort(key = lambda x: x[2], reverse=True)

    top_choice = set()
    second = []

    top = 0
    second_score = 0
    num_rem = 0
    j=0
    while(True):
        j = 0
        for found, path, num in all_found:
            #print(found)
            #print(path)
            #print(num)
            if not top_choice:
                for i in found:
                    top_choice.add(i)
                top = num
                if num_rem > j:
                    j += 1
                    top_choice = set()
            else:
                if num >= second_score:
                    second_score = num
                else:
                    remove = []
                    for i in top_choice:
                        if i not in second:
                            remove.append(i)
                    for i in remove:
                        top_choice.remove(i)
                    second = []
                second += found
        if num_rem < max_sub and o in top_choice:
            print("REMOVED!")
            top_choice = set()
            num_rem += 1
        else:
            break

            
    print(top_choice)
    print(top)
    print(o)

    ret = False
    if o in top_choice:
        ret = True
    
    return ret, top, num_rem

#given s and o, should r exist?
def rulen_mod(s, r, o, paths, data, data_s,  max_sub=0):
    all_found = []
    for path in paths:
       found = path_check(s, path, 0, data_s)
       if found:
           all_found.append((found, path, paths[path]))
           #print(paths[path])

    #all_found.sort(key = lambda x: x[2], reverse=True)
    #print("PATHS: {}".format(len(paths)))
    #print("AF: {}".format(len(all_found)))

    top_choice = set()
    second = []

    top = 0
    second_score = 0
    num_rem = 0
    j = 0
    
    found_list = []

    for found, path, num in all_found:
        #print(found)
        #print(path)
        #print(num)
        if o in found:
            found_list.append((found, path, num))
            if top == 0:
                top = num
            
            
    #print(top_choice)
    #print(top)
    #print(o)

    ret = False
    if o in top_choice:
        ret = True
    
    return top, found_list

def remove_r(data, data_s, s, path, o):

    rem_link = path[0]

    del data[rem_link][s]
    del data_s[s][rem_link]
    
    print("DEL")
    return data, data_s

if __name__ == "__main__":
    #data_fp = "./data/FB15K237/train.txt"
    data_fp = "./data/fb237_v1/train.txt"
    files = ["./data/FB15K237/train.txt", "./data/FB15K237/valid.txt", "./data/FB15K237/test.txt"]
    o_data, o_data_s = load_data(data_fp)
    random.seed(123)
    count = 0
    ten_count = 0
    scores = []
    ranks = []
    rem1 = 0
    rem2 = 0
    rules = {}

    rs = o_data.keys()

    sub = 1
    k = 2

    found_dict = {}
    target = "/m/07q1v4"
    subject = "/m/0f8l9c"

    for data_fp in files:
        o_data, o_data_s = load_data(data_fp)
        if target in o_data_s:
            for r, data_r in o_data_s[target].items():
                print(r)
               
                for s2 in data_r:
                    print(s2)
                    if s2 == subject:
                        print("{},   {},   {}".format(target, r, s2))

                        
                        
    exit()
    #EDIT
    #for i in tqdm(range(100)):
    for i in tqdm(range(1)):
        ret = None
        cur_sub = sub

        #EDIT
        #given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
        #def find_surrounding_nodes(data_s, s, target_o, steps, k, paths, prev_path):
        target = "/m/07q1v4"
        subject = "/m/0f8l9c"
        


    
        
        while(ret==None):
            top_rule_list = []

            data = copy.deepcopy(o_data)
            data_s = copy.deepcopy(o_data_s)
            s,r,o = select_target(data)
            
            #EDIT
            ret = True
            all_hops = set()
            hops1 = set()
            hops2 = set()
            hops3 = set()

            paths = {}

            prev_path = ()

            find_surrounding_nodes_triples(data_s, target, subject, 0, 3, paths, prev_path)
            print(paths)
            for ts in paths:
                for t in ts:
                    all_hops.add(t)
                    print(t)

            
            

            all_hops.add(target)
            all_hops.add(subject)
          
            
            # for sr, sol in data_s[target].items():
            #     for so in sol:
            #         #print(so)
            #         hops1.add(so)
            #         all_hops.add(so)
            # for new_s in hops1:
            #     if new_s not in data_s:
            #         continue
            #     for sr, sol in data_s[new_s].items():
            #         for so in sol:
            #             hops2.add(so)
            #             all_hops.add(so)
            # for new_s in hops2:
            #     if new_s not in data_s:
            #         continue
            #     for sr, sol in data_s[new_s].items():
            #         for so in sol:
            #             hops3.add(so)
            #             all_hops.add(so);
            print(len(list(all_hops)))
            #print(all_hops)
            print(subject in all_hops)
            print(len(data.keys()))
            out_fp  = "./train.txt"
            count = 0
            new_hops = set()
            new_hops.add(subject)
            new_hops.add(target)
            with open(out_fp, "w") as fp:
                for s, data_s1 in data_s.items():
                    #print(s)
                    if s not in all_hops:
                        continue
                    
                    #print("HERE2!")
                    for r, data_r in data_s1.items():
                        for sr in data_r:
                            count += 1
                            if sr not in all_hops:
                                continue
                    
                            fp.write(s + " " + r + " " + sr + "\n")

            
            exit

            
            
            data[r][s].remove(o)
            if len(data[r][s]) < 1:
                del data[r][s]

            data_s[s][r].remove(o)
            if len(data_s[s][r]) < 1:
                del data_s[s][r]

            all_found_list = {}
            
            #print("S: {}\t O: {}\t R: {}".format(s,o, r))
            #print(data_s['/m/0c8wxp'])
            for r_check in rs:
                #print("On rule {}".format(r_check))
                if r_check not in rules:
                    paths = random_sample_relation(data, data_s, r_check, sample_no=30, k = k)

                    sorted_paths = {k: v for k, v in sorted(paths.items(), key=lambda item: item[1], reverse=True)}

                    if (r_check,) in sorted_paths:
                        del sorted_paths[r_check,]
                    rules[r_check] = sorted_paths

                #print(sorted_paths)


                #res, num, rem = rulen_mod(s, r, o, rules[r], data, data_s, max_sub=0)
                num, found_list = rulen_mod(s, r_check, o, rules[r_check], data, data_s, max_sub=0)
                top_rule_list.append((r_check, num))
                if found_list:
                    #print("FOUND LIST: {}".format(found_list))
                    all_found_list[r_check] = found_list

            top_rule_list.sort(key=lambda x: x[1], reverse=True)
            for i, (r_rank, score) in enumerate(top_rule_list):
                if r == r_rank:
                    #print("R at rank {}".format(i))
                    break
            if cur_sub > 0 and i == 0:
                cur_sub -=1

                #print(all_found_list)
                try:
                    data, data_s = remove_r(data, data_s, s, all_found_list[r][0][1], o)
                except:
                    continue
                
            else:
                ret = True
                if i  == 0:
                    count += 1
                if i < 10:
                    ten_count += 1

        ranks.append(i)
        scores.append(score)
        

    print("Correct: {}".format(count/100))
    print("Top 10: {}".format(ten_count/100))
    print("Total Rules: {}".format(len(rs)))
    print("Avg Score: {}".format(np.mean(scores)))
    print("Std dev: {}".format(np.std(scores)))
    print("Avg Ranks: {}".format(np.median(ranks)))
    print("Std dev: {}".format(np.std(ranks)))
    
    #print("rem1: {}".format(rem1))
    #print("rem2: {}".format(rem2))


