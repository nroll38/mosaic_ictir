import numpy as np
from tqdm import tqdm
import csv
import random
import copy

def load_data(fp):
    data = {}
    data_s = {}

    with open(fp, "r") as fd:
        rd = csv.reader(fd, delimiter="\t")
        for row in rd:
            (s, r, o)  = row
            
            if r not in data:
                data[r] = {}
            if s not in data[r]:
                data[r][s] = [o]
            else:
                data[r][s].append(o)

            if s not in data_s:
                data_s[s] = {}
            if r not in data_s[s]:
                data_s[s][r] = [o]
            else:
                data_s[s][r].append(o) 
    
    return data, data_s

def load_set(fp):

    ret_set = set()
    with open(fp, "r") as fd:
        rd = csv.reader(fd, delimiter="\t")
        for row in rd:
            (s, r, o)  = row
            ret_set.update((s, r, o))
    return ret_set
            

def find_paths(data_s, secret):
    in_paths = set()
    o_nodes = set()
    
    (sec_s, sec_r, sec_o) = secret

    #find 1 hop around secret object
    for r in data_s[sec_o]:
        o_nodes.update(data_s[sec_o][r])

    #find 1 hop, 2 hop around secret subject
    for r in data_s[sec_s]:
        if s
    
    
    
    return


#given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
def find_surrounding_nodes_triples(data_s, s, target_o, steps, k, paths, prev_path):
    if s not in data_s:
        return
    
    for r, o_list in data_s[s].items():
        for o in o_list:
            #print("PREV PATH: {}".format(len(prev_path)))
            cur_path = prev_path + (s,)
            #print("CUR PATH: {}".format(len(cur_path)))
            #print("CUR PATH: {}".format(cur_path))
            if o == target_o:
                path = tuple(cur_path)
                #print("PATH: {}".format(path))
                if path not in paths:
                    paths[path] = 1
                else:
                    paths[path] += 1
                continue
            if steps < k-1:
                find_surrounding_nodes_triples(data_s, o, target_o, steps + 1, k, paths, cur_path)
                
                    

if __name__ == "__main__":
    data_fp = "./data/exp_v1_33/test/train.txt"
    secret_fp = "./data/exp_v1_33/test/test.txt"
    new_data_fp = "./data/exp_v1_33/new.txt"
    data, data_s = load_data(data_fp)
    secrets = load_set(secret_fp)
    new_data = load_set(new_data_fp)

    for secret in secrets:
        print secret
    
    # for secret_r, secret_r_dict in secrets.items():
    #     for secret_s, secret_s_list in secret_r_dict.items():
    #         for secret_o in secret_s_list:
    #             find_surrounding_nodes_triples(

    

    
