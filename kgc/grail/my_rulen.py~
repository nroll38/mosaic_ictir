import numpy as np
from tqdm import tqdm
import csv
import random
import copy
import argparse
import json

import test_ranking

def load_data(fp):
    data = {}
    data_s = {}

    with open(fp, "r") as fd:
        rd = csv.reader(fd, delimiter="\t")
        for row in rd:
            (s, r, o)  = row
            
            if r not in data:
                data[r] = {}
            if s not in data[r]:
                data[r][s] = [o]
            else:
                data[r][s].append(o)

            if s not in data_s:
                data_s[s] = {}
            if r not in data_s[s]:
                data_s[s][r] = [o]
            else:
                data_s[s][r].append(o) 
    
    return data, data_s

def load_set(fp):

    ret_set = set()
    with open(fp, "r") as fd:
        rd = csv.reader(fd, delimiter="\t")
        for row in rd:
            (s, r, o)  = row
            ret_set.add((s,r,o))
    return ret_set

#randomly select target tuple
def select_target(data):

    r, s_dict = random.choice(list(data.items()))
    s, o_list = random.choice(list(s_dict.items()))
    o = random.choice(o_list)
    
    
    return (s,r,o)

#given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
def find_surrounding_nodes(data_s, s, target_o, steps, k, paths, prev_path):
    if s not in data_s:
        return
    out = []
    for r, o_list in data_s[s].items():
        for o in o_list:
            #print("PREV PATH: {}".format(len(prev_path)))
            cur_path = prev_path + (r,)
            #print("CUR PATH: {}".format(len(cur_path)))
            #print("CUR PATH: {}".format(cur_path))
            if o == target_o:
                path = tuple(cur_path)
                #print("PATH: {}".format(path))
                if path not in paths:
                    paths[path] = 1
                else:
                    paths[path] += 1
                continue
            if steps < k-1:
                find_surrounding_nodes(data_s, o, target_o, steps + 1, k, paths, cur_path)
                

#given s, target, steps, find surrounding nodes and recusively call until target found or max steps(k) reached
def find_surrounding_nodes_triples(data_s, s, target_o, steps, k, paths, prev_path):
    if s not in data_s:
        return
    
    for r, o_list in data_s[s].items():
        for o in o_list:
            #print("PREV PATH: {}".format(len(prev_path)))
            cur_path = prev_path + (s,)
            #print("CUR PATH: {}".format(len(cur_path)))
            #print("CUR PATH: {}".format(cur_path))
            if o == target_o:
                path = tuple(cur_path)
                #print("PATH: {}".format(path))
                if path not in paths:
                    paths[path] = 1
                else:
                    paths[path] += 1
                continue
            if steps < k-1:
                find_surrounding_nodes_triples(data_s, o, target_o, steps + 1, k, paths, cur_path)
                
                    
    

#given r, random sample relations to find path prominence
def random_sample_relation(data, data_s, relation, sample_no=10, k = 2):
    rel_dict = data[relation]
    s_list = list(rel_dict.keys())
    
    #TODO: SO_LIST for multiple o's with same sr
    if len(s_list) == 0:
        return {}
    chosen_s = random.sample(s_list, min(sample_no, len(s_list)))

    paths = {}
    
    

    for s in chosen_s:
        cur_path = ()
        steps = 0
        target_o = rel_dict[s][0]
        
        find_surrounding_nodes(data_s, s, target_o, steps, k, paths, cur_path)
        #visited = set()
        #visited.add(s)
        #target_o = rel_dict[s][0]
        #depth = 0

        
        #for r in data_s[s].keys():
            
            
            
        
    

        
    #print(len(paths))
    pks = paths.keys()
    for k in pks:
        paths[k] = min(paths[k]/len(chosen_s), 1.0)
    return paths

def path_check(s, path, hop, data_s):
    found = []
    if len(path) == hop:
        return [s]
    r = path[hop]
    if s in data_s and r in data_s[s]:
        for o in data_s[s][r]:
            found += path_check(o, path, hop + 1, data_s)
    return found


#given s and o, should r exist?
def rulen_mod(s, r, o, paths, data, data_s,  max_sub=0):
    all_found = []
    for path in paths:
       found = path_check(s, path, 0, data_s)
       if found:
           all_found.append((found, path, paths[path]))
           #print(paths[path])

    #all_found.sort(key = lambda x: x[2], reverse=True)
    print("PATHS: {}".format(len(paths)))
    print("AF: {}".format(len(all_found)))

    top_choice = set()
    second = []

    top = 0
    second_score = 0
    num_rem = 0
    j = 0
    
    found_list = []

    for found, path, num in all_found:
        #print(found)
        #print(path)
        #print(num)
        if o in found:
            found_list.append((found, path, num))
            if top == 0:
                top = num
            
            
    #print(top_choice)
    #print(top)
    #print(o)

    ret = False
    if o in top_choice:
        ret = True
    
    return top, found_list

#given s and r, what is best o?
def rulen(s, r, o, paths, data, data_s, rules, max_sub=0):
    all_found = []
    for path in paths:
       found = path_check(s, path, 0, data_s)
       if found:
           all_found.append((found, path, paths[path]))
           
    all_found.sort(key = lambda x: x[2], reverse=True)

    top_choice = set()
    second = []

    top = 0
    second_score = 0
    num_rem = 0
    j=0
    while(True):
        j = 0
        for found, path, num in all_found:
            #print(found)
            #print(path)
            #print(num)
            if not top_choice:
                for i in found:
                    top_choice.add(i)
                top = num
                if num_rem > j:
                    j += 1
                    top_choice = set()
            else:
                if num >= second_score:
                    second_score = num
                else:
                    remove = []
                    for i in top_choice:
                        if i not in second:
                            remove.append(i)
                    for i in remove:
                        top_choice.remove(i)
                    second = []
                second += found
        if num_rem < max_sub and o in top_choice:
            print("REMOVED!")
            top_choice = set()
            num_rem += 1
        else:
            break

            
    print(top_choice)
    print(top)
    print(o)

    ret = False
    if o in top_choice:
        ret = True
    
    return ret, top, num_rem



def remove_r(data, data_s, s, path, o):

    rem_link = path[0]

    del data[rem_link][s]
    del data_s[s][rem_link]
    
    print("DEL")
    return data, data_s

def find_rules(data, data_s, rs, k):
    rules = {}
    for r_check in rs:
        #print("On rule {}".format(r_check))
        if r_check not in rules:
            paths = random_sample_relation(data, data_s, r_check, sample_no=30, k = k)

            sorted_paths = {k: v for k, v in sorted(paths.items(), key=lambda item: item[1], reverse=True)}

            if (r_check,) in sorted_paths:
                del sorted_paths[r_check,]
            rules[r_check] = sorted_paths

        #print(sorted_paths)
    return rules

def get_negative_samples(data_fp, secrets_fp, rel2id_fp):
    fps= {}
    fps["graph"] = data_fp
    fps["links"] = secrets_fp

    neg_triple_out = {}

    with open(rel2id_fp, "r") as fd:
        rel2id = json.load(fd)
    
    
    adj_list, _, triples, _, _, id2entity, id2relation = test_ranking.process_files(fps, rel2id, False)
    neg_triples = test_ranking.get_neg_samples_replacing_head_tail(triples["links"], adj_list)

    #print(rel2id)

    for entry in neg_triples:
        
        for k, v in entry.items():
            for i, triple in enumerate(v[0]):
                out = ""
                #print(triple)
                triple_text = (id2entity[triple[0]], id2relation[triple[2]], id2entity[triple[1]])
                
                if k == "head" and i == 0:
                    cur_secret = triple_text
                    neg_triple_out[cur_secret] = {}
                if k not in neg_triple_out[cur_secret]:
                    neg_triple_out[cur_secret][k] = []
                neg_triple_out[cur_secret][k].append(triple_text)
                    
                    

                
                
                #break
            #break
            #print(neg_triples[0])
    
    #print(neg_triple_out[cur_secret].keys())
    return neg_triple_out

                                                    


if __name__ == "__main__":
    #data_fp = "./data/FB15K237/train.txt"
    rules_data_fp = "./data/exp_v1_33/train/train.txt"
    data_fp = "./data/exp_v1_33/test/train.txt"
    #files = ["./data/FB15K237/train.txt", "./data/FB15K237/valid.txt", "./data/FB15K237/test.txt"]
    #secrets_fp = "./data/exp_v1_33/test/test.txt"
    secrets_fp = "./data/exp_v1_33/secrets.txt"
    rules_dict = "./rulen_rules.json"
    rel2id_fp = "./data/exp_v1_33/relation2id.json"
    
    data, data_s = load_data(data_fp)
    rules_data, rules_data_s = load_data(rules_data_fp)
    secrets = load_set(secrets_fp)
    random.seed(123)
    count = 0
    ten_count = 0
    scores = []
    ranks = []
    rem1 = 0
    rem2 = 0
    rules = {}

    rs = data.keys()

    sub = 0
    k = 3

    found_dict = {}

    negative_samples = get_negative_samples(data_fp, secrets_fp, rel2id_fp)

    #Gen Rules
    try:
        with open(rules_dict, "r") as fd:
            rules = json.load(fd)
    except:
        rules = find_rules(data, data_s, rs, k)


    #EDIT
    #for i in tqdm(range(100)):
    for secret in secrets:
        ret = None
        cur_sub = sub
   
        
        while(ret==None):
            top_rule_list = []
            (s,r,o) = secret

            
            #data = copy.deepcopy(o_data)
            #data_s = copy.deepcopy(o_data_s)
            (s,r,o) = secret#select_target(data)

            #not in data
            # data[r][s].remove(o)
            # if len(data[r][s]) < 1:
            #     del data[r][s]

            # data_s[s][r].remove(o)
            # if len(data_s[s][r]) < 1:
            #     del data_s[s][r]

            all_found_list = {}
            
            #print("S: {}\t O: {}\t R: {}".format(s,o, r))
            #print(data_s['/m/0c8wxp'])
            for r_check in rs:
                #print("On rule {}".format(r_check))
                if r_check not in rules:
                    paths = random_sample_relation(data, data_s, r_check, sample_no=30, k = k)

                    sorted_paths = {k: v for k, v in sorted(paths.items(), key=lambda item: item[1], reverse=True)}

                    if (r_check,) in sorted_paths:
                        del sorted_paths[r_check,]
                    rules[r_check] = sorted_paths

                #print(sorted_paths)


                #res, num, rem = rulen_mod(s, r, o, rules[r], data, data_s, max_sub=0)
                num, found_list = rulen_mod(s, r_check, o, rules[r_check], data, data_s, max_sub=0)
                top_rule_list.append((r_check, num))
                if found_list:
                    #print("FOUND LIST: {}".format(found_list))
                    all_found_list[r_check] = found_list

            top_rule_list.sort(key=lambda x: x[1], reverse=True)
            for i, (r_rank, score) in enumerate(top_rule_list):
                if r == r_rank:
                    #print("R at rank {}".format(i))
                    break
            if cur_sub > 0 and i == 0:
                cur_sub -=1

                #print(all_found_list)
                try:
                    data, data_s = remove_r(data, data_s, s, all_found_list[r][0][1], o)
                except:
                    continue
                
            else:
                ret = True
                if i  == 0:
                    count += 1
                if i < 10:
                    ten_count += 1

        ranks.append(i)
        scores.append(score)
        

    print("Correct: {}".format(count/100))
    print("Top 10: {}".format(ten_count/100))
    print("Total Rules: {}".format(len(rs)))
    print("Avg Score: {}".format(np.mean(scores)))
    print("Std dev: {}".format(np.std(scores)))
    print("Avg Ranks: {}".format(np.median(ranks)))
    print("Std dev: {}".format(np.std(ranks)))
    
    #print("rem1: {}".format(rem1))
    #print("rem2: {}".format(rem2))


